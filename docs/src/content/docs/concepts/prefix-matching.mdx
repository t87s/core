---
title: Prefix Matching
description: Hierarchical cache invalidation with prefix matching
---

Prefix matching is t87s's killer feature. When you invalidate a tag, all "child" tags are also invalidated.

## How It Works

```typescript
const tags = defineTags({
  user: (id: string) => ['user', id],
  userPosts: (id: string) => ['user', id, 'posts'],
  userSettings: (id: string) => ['user', id, 'settings'],
});

// Invalidating tags.user('123') also invalidates:
// - ['user', '123']           ← exact match
// - ['user', '123', 'posts']  ← prefix match
// - ['user', '123', 'settings'] ← prefix match
```

## The Problem It Solves

Without prefix matching, you'd need to remember every related cache key:

```typescript
// Manual approach (error-prone)
cache.delete('user:123');
cache.delete('user:123:posts');
cache.delete('user:123:settings');
// Did you forget user:123:notifications? Stale data.
```

With t87s:

```typescript
// Declarative approach (complete)
return { invalidates: [tags.user(id)] };
// All children automatically invalidated
```

## Exact Mode

If you only want to invalidate the exact tag:

```typescript
return {
  invalidates: [tags.user(id)],
  exact: true, // Only invalidates ['user', '123'], not children
};
```

Use sparingly—prefix matching is usually what you want.
