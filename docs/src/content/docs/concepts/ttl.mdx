---
title: TTL
description: How long your cache gets to be right
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

TTL is Time To Live. It's how long a cache entry stays fresh before it expires and has to be recomputed.

<Tabs>
  <TabItem label="TypeScript">
    ```typescript
    import { QueryCache, at, wild, MemoryAdapter } from '@t87s/core';

    const schema = at('users', () => wild);
    const adapter = new MemoryAdapter();

    const cache = QueryCache({
      schema,
      adapter,
      defaultTtl: '10m',
      queries: (tags) => ({
        getUser: (id: string) => ({
          tags: [tags.users(id)],
          ttl: '2m',
          fn: () => db.users.findById(id),
        }),
      }),
    });

    await cache.primitives.set('users:settings', settings, {
      tags: [['users', 'settings']],
      ttl: '1h',
    });
    ```
  </TabItem>
  <TabItem label="Python">
    ```python
    from t87s import QueryCache, TagSchema, Wild
    from t87s.adapters import AsyncMemoryAdapter

    class Tags(TagSchema):
        users: Wild[TagSchema]

    class Cache(QueryCache[Tags]):
        pass

    cache = Cache(
        adapter=AsyncMemoryAdapter(),
        default_ttl="10m",
    )

    await cache.primitives.set(
        "users:settings",
        settings,
        tags=[("users", "settings")],
        ttl="1h",
    )
    ```
  </TabItem>
</Tabs>

We accept human strings like "30s", "5m", "2h", and "1d", plus raw milliseconds if you enjoy typing zeros.

Short TTLs fit dashboards and sessions. Long TTLs fit config and content that sleeps more than it moves. If you forget to invalidate, TTL is the safety net that keeps your cache from lying forever.
