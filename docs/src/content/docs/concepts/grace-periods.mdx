---
title: Grace Periods
description: Stale data with a conscience
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

Grace lets you serve stale data when the source is down. It's the difference between a hiccup and a public apology.

<Tabs>
  <TabItem label="TypeScript">
    ```typescript
    import { QueryCache, at, wild, MemoryAdapter } from '@t87s/core';

    const cache = QueryCache({
      schema: at('users', () => wild),
      adapter: new MemoryAdapter(),
      defaultGrace: '2m',
      queries: (tags) => ({
        getUser: (id: string) => ({
          tags: [tags.users(id)],
          ttl: '30s',
          grace: '10m',
          fn: () => db.users.findById(id),
        }),
      }),
    });

    await cache.getUser('123');
    ```
  </TabItem>
  <TabItem label="Python">
    ```python
    from t87s import QueryCache, TagSchema, Wild, cached
    from t87s.adapters import AsyncMemoryAdapter

    class Tags(TagSchema):
        users: Wild[TagSchema]

    class Cache(QueryCache[Tags]):
        @cached(Tags.users())
        async def get_user(self, id: str):
            return await db.users.find_by_id(id)

    cache = Cache(
        adapter=AsyncMemoryAdapter(),
        default_grace="2m",
    )

    await cache.primitives.query(
        key="user:123",
        tags=[("users", "123")],
        fn=lambda: db.users.find_by_id("123"),
        ttl="30s",
        grace="10m",
    )
    ```
  </TabItem>
</Tabs>

When TTL expires, t87s tries to refresh. If refresh fails and the stale entry is still within grace, you get the old value and a background retry instead of a 500. It's boring in the best way.
