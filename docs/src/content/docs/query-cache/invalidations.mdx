---
title: Invalidations
description: How to tell the cache that something changed
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

Here's the deal with caching: at some point, the cached data becomes wrong. The user updated their profile. An order shipped. A comment was deleted. When that happens, you need to tell the cache, or it'll keep serving the old data like nothing happened.

This is invalidation, and it's the part of caching that people actually mess up. The fetching and storing is easy. The "knowing when to throw it away" is hard. t87s tries to make it less hard.

## Basic invalidation

<Tabs>
  <TabItem label="TypeScript">
    ```typescript
    // Invalidate one user
    await cache.invalidate(cache.tags.users('123'));

    // Invalidate ALL users (nuclear option)
    await cache.invalidate(cache.tags.users);

    // Invalidate a specific post
    await cache.invalidate(cache.tags.users('123').posts('p1'));
    ```
  </TabItem>
  <TabItem label="Python">
    ```python
    # Invalidate one user
    await cache.invalidate(cache.t.users("123"))

    # Invalidate ALL users (nuclear option)
    await cache.invalidate(cache.t.users)

    # Invalidate a specific post
    await cache.invalidate(cache.t.users("123").posts("p1"))
    ```
  </TabItem>
</Tabs>

When you invalidate a tag, everything *under* that tag goes stale too. Invalidating `users('123')` also invalidates `users('123').posts('p1')` and `users('123').posts('p1').comments('c9')` and so on. This is called prefix matching, and it's almost always what you want.

If you're updating a user, you probably want their cached posts and comments to refresh tooâ€”they might depend on the user's name or avatar or some other field that just changed. Prefix matching handles this automatically.

## Exact invalidation

Sometimes you *don't* want the cascade. Maybe you updated a user's email but their posts and comments are genuinely unaffected. In that case, you can do an exact invalidation:

<Tabs>
  <TabItem label="TypeScript">
    ```typescript
    // Only invalidate users:123, NOT users:123:posts:*
    await cache.invalidate(cache.tags.users('123'), true);

    // Or via primitives:
    await cache.primitives.invalidate([['users', '123']], { exact: true });
    ```
  </TabItem>
  <TabItem label="Python">
    ```python
    # Python support for exact invalidation is coming soon.
    # For now, use prefix invalidation, which is the safer default anyway.
    await cache.invalidate(cache.t.users("123"))
    ```
  </TabItem>
</Tabs>

Be careful with exact invalidation. It's an optimization, and like most optimizations, it can bite you if you're wrong about what's affected. When in doubt, let the prefix cascade happen.

## When to invalidate

The obvious answer is "when the data changes." But *where* you put that invalidation call matters.

**After writes, not before.** You want to invalidate after the database write succeeds, not before. If you invalidate first and then the write fails, you've just cleared good data for no reason.

**Close to the mutation.** Put your invalidation calls near the code that mutates the data. If `updateUser()` changes the database, it should also invalidate the cache. Don't scatter invalidations across unrelated files where you'll forget about them.

**Consider side effects.** Sometimes updating one thing affects another. If updating a user's name should also invalidate their comments (because comments display the author name), make sure that invalidation happens. This is the part people forget.

I've debugged more cache bugs that boil down to "we forgot to invalidate X when Y changed" than I care to admit. The fix is always obvious in retrospect, which makes it even more frustrating.
