---
title: Query Definitions
description: Declare once, call forever
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

Query definitions turn into methods. The cache key is derived from the method name plus its args, so you never have to hand-roll keys unless you want to.

<Tabs>
  <TabItem label="TypeScript">
    ```typescript
    import { QueryCache, at, wild, MemoryAdapter } from '@t87s/core';

    const cache = QueryCache({
      schema: at('users', () => wild),
      adapter: new MemoryAdapter(),
      defaultTtl: '1m',
      defaultGrace: '5m',
      verifyPercent: 0.1,
      queries: (tags) => ({
        getUser: (id: string) => ({
          tags: [tags.users(id)],
          fn: () => db.users.findById(id),
        }),
      }),
    });

    await cache.getUser('123');
    ```
  </TabItem>
  <TabItem label="Python">
    ```python
    from t87s import QueryCache, TagSchema, Wild, cached
    from t87s.adapters import AsyncMemoryAdapter

    class Tags(TagSchema):
        users: Wild[TagSchema]

    class Cache(QueryCache[Tags]):
        @cached(Tags.users())
        async def get_user(self, id: str):
            return await db.users.find_by_id(id)

    cache = Cache(
        adapter=AsyncMemoryAdapter(),
        default_ttl="1m",
        default_grace="5m",
        verify_percent=0.1,
    )

    await cache.get_user("123")
    ```
  </TabItem>
</Tabs>

You can still drop to primitives when you need custom keys or a one-off cache path. QueryCache keeps the happy path short.
